# 需求文档：开发者自我代码回顾与成长分析工具 (LLM-Powered)

**版本：** 1.0
**日期：** 2025-5-9
**负责人：** [您的名字/团队]

## 1. 引言

### 1.1. 项目目标

开发一款利用大语言模型 (LLM) 能力的工具，帮助开发者通过系统性地分析自己在过去一段时间内（主要基于 GitHub 提交记录）编写的代码，识别编码模式、技术成长、潜在问题和改进机会。核心目标是**促进开发者的个人技术能力持续提升和良好编码习惯的养成**，使其成为一个个性化的 AI 编码导师和成长伙伴。

### 1.2. 目标用户

主要为希望进行自我代码回顾和提升的**独立开发者**。

### 1.3. 项目范围

- **核心功能：** 连接 GitHub 获取代码，利用 LLM 进行多维度分析，生成富有洞察和启发性的反馈报告，重点关注开发者成长。
- **初期不包含：** 团队协作分析、实时代码分析 (IDE 插件等，可作为远期目标)。

## 2. 系统概述

本工具将作为一个独立的 Web 应用（初期或桌面应用），用户通过 GitHub OAuth 授权后，选择需要分析的仓库和时间范围。后端服务将拉取相关代码的 diff 信息，并将其分片或摘要后提交给大语言模型进行分析。分析结果将结构化地存储，并通过用户友好的界面展示给开发者，包含代码片段、LLM 的点评、改进建议以及潜在的成长点。

**核心流程：**

1.  用户授权 GitHub。
2.  用户选择仓库、分支、时间范围。
3.  系统获取指定范围内的 commits 和代码变更 (diffs)。
4.  系统将代码变更信息（结合上下文）发送给 LLM 进行分析。
5.  LLM 返回分析结果（问题、建议、解释、优点等）。
6.  系统解析并存储 LLM 的反馈。
7.  用户在前端界面查看结构化的分析报告，并可进行交互。

## 3. 功能需求 (Functional Requirements)

### FR1: GitHub 集成与代码获取

- **FR1.1: GitHub OAuth 授权：**
  - 描述：用户应能通过安全的 OAuth2.0 流程授权应用访问其 GitHub 账户数据。
  - 细节：仅申请必要的权限（如 `repo` 读取权限）。
- **FR1.2: 仓库选择：**
  - 描述：用户授权后，应能列出其有权访问的仓库，并选择一个或多个仓库进行分析。
  - 细节：支持搜索/筛选仓库列表。
- **FR1.3: 分支与时间范围选择：**
  - 描述：用户应能为选定的仓库选择特定分支（默认为主分支）和分析的时间范围（如过去7天、过去30天、自定义日期范围）。
  - 细节：提供易用的日期选择器。
- **FR1.4: 提交历史获取：**
  - 描述：系统应能根据用户选择拉取指定范围内的提交历史记录 (commit logs)。
  - 细节：只拉取该用户作为 author 的提交。
- **FR1.5: 代码变更获取 (Diffs)：**
  - 描述：系统应能获取每次提交所涉及的代码变更内容 (diffs)。
  - 细节：关注新增和修改的代码行。

### FR2: 基于 LLM 的代码分析引擎

- **FR2.1: 代码预处理与分片：**
  - 描述：在将代码提交给 LLM 前，系统需要对代码 diff 进行预处理。对于大型 diff，可能需要进行智能分片或摘要，以符合 LLM 的输入长度限制并保证分析质量。
  - 细节：分片时应尽量保持代码上下文的完整性。
- **FR2.2: 核心分析维度 (可配置/逐步实现)：**
  - **FR2.2.1: 代码质量与可维护性分析：**
    - **可读性：** 命名、结构、函数/类长度、注释质量。LLM 应能识别模糊的命名、复杂的逻辑块，并建议改进。
    - **代码重复 (DRY)：** LLM 辅助识别可抽象和复用的代码段。
    - **错误处理：** 分析异常捕获、处理的完整性和健壮性。
    - **成长视角：** 不仅指出问题，更要解释"为什么这是问题"以及"改进后对可维护性/可读性的益处"。
  - **FR2.2.2: 技术运用与设计模式识别：**
    - **编程原则：** 尝试识别 SOLID、KISS、YAGNI 等原则的遵循或违背情况。
    - **设计模式：** 识别常见设计模式的应用，或建议在何处可以使用设计模式优化。
    - **框架/库用法：** 分析对所用框架/库的API使用是否最佳，有无更推荐的用法。
    - **成长视角：** 启发开发者思考"是否有更优的设计？""当前设计解决了什么问题，可能引入什么新问题？"
  - **FR2.2.3: 测试相关性分析 (初步)：**
    - **测试缺失提醒：** 对于新增的复杂逻辑，如果附近没有测试代码变更，LLM 可提示风险。
    - **成长视角：** 强调编写测试的重要性，引导思考"如何为这段代码编写有效的测试？"
  - **FR2.2.4: 潜在的 Bug 或风险提示：**
    - LLM 根据其知识库尝试识别常见的逻辑错误、边界条件处理不当、潜在的空指针等。
    - **成长视角：** 解释这类风险的常见成因和预防方法。
  - **FR2.2.5: 优点识别与鼓励：**
    - LLM 应能识别代码中的优点，如清晰的逻辑、优秀的设计、良好的注释等，并给予正面反馈。
    - **成长视角：** 强化开发者的良好编码习惯。
- **FR2.3: LLM Prompt 工程：**
  - 描述：精心设计向 LLM 发出的 Prompt，以引导其从"帮助开发者成长"的角度进行分析。
  - 细节：
    - Prompt 应包含代码片段、相关的上下文信息（如文件名、所属模块、提交信息）。
    - Prompt 应明确指示 LLM 关注的分析维度，并强调解释性、启发性和建设性。
    - 例如："作为一位资深开发者导师，请分析以下代码变更。关注其可读性、设计模式应用和潜在改进点。请解释你的分析，并提供具体的、可操作的建议以帮助提交者成长。同时，也请指出代码中值得肯定的地方。"
- **FR2.4: LLM 响应处理：**
  - 描述：系统应能解析 LLM 返回的分析结果，并将其结构化存储。
  - 细节：可能需要定义一种数据结构来存储不同维度的分析、建议、代码位置引用等。

### FR3: 用户界面 (UI) 与分析报告展示

- **FR3.1: 分析结果仪表盘：**
  - 描述：提供一个总览页面，展示一段时间内代码分析的摘要信息。
  - 细节：例如，识别出的主要问题类型分布、优点数量、代码复杂度趋势（如果能分析）等。
- **FR3.2: 详细分析报告：**
  - 描述：用户可以查看每次提交或每个文件的详细分析结果。
  - 细节：
    - 清晰展示原始代码片段（diff 视图高亮）。
    - 在代码旁边或下方展示 LLM 的点评、解释和建议。
    - 支持对特定分析点进行展开/折叠。
- **FR3.3: 启发式提问与引导：**
  - 描述：UI 在展示 LLM 建议时，可以附加一些引导性问题，鼓励用户深入思考。
  - 例子："对于这个建议，你认为它在当前项目背景下是否适用？为什么？"
- **FR3.4: 用户反馈机制：**
  - 描述：用户可以对 LLM 的某条分析标记为"有帮助"、"无帮助"或提供简短反馈。
  - 细节：此反馈可用于未来优化 Prompt 或评估 LLM 效果。
- **FR3.5: 个人笔记与反思：**
  - 描述：用户可以针对分析结果或特定代码片段添加自己的笔记和反思。
  - 细节：这些笔记与分析结果一同保存。
- **FR3.6: 报告导出：**
  - 描述：用户可以将分析报告（或其摘要）导出为 Markdown 或 PDF 格式。
  - 细节：方便用户离线查看或归档。

### FR4: 个性化与配置

- **FR4.1: 分析焦点自定义（可选，后期）：**
  - 描述：允许用户选择或调整在分析中更关注的维度（如"我最近想提升错误处理能力"）。
- **FR4.2: LLM 模型配置（后台）：**
  - 描述：后台应支持配置使用的 LLM API Endpoint、密钥等。
  - 细节：考虑未来可能支持切换不同模型。

## 4. 非功能需求 (Non-Functional Requirements)

- **NFR1: 性能：**
  - 代码获取和分析过程不应过长，对于中等规模的提交历史（如一个月），应在可接受的时间内（例如几分钟内）返回结果。
  - UI 响应流畅。
- **NFR2: 隐私与安全：**
  - GitHub Token 必须安全存储（例如加密存储，或仅在会话期间内存中保存）。
  - 明确告知用户代码数据将如何被使用（特别是与 LLM 交互时）。如果使用第三方 LLM API，应有明确的数据策略说明。**强烈建议探索和优先考虑使用本地化部署的 LLM 模型或提供相关选项，以最大程度保护用户代码隐私。**
- **NFR3: 易用性：**
  - 界面直观简洁，用户无需复杂配置即可开始使用。
  - LLM 的反馈应易于理解，避免过于技术化或模糊的表述。
- **NFR4: 准确性与可靠性：**
  - 虽然 LLM 的分析可能不完美，但应力求提供有价值且大概率准确的反馈。
  - 系统应能妥善处理 LLM API 调用失败或返回异常的情况。
- **NFR5: 可扩展性：**
  - 系统设计应便于未来增加新的分析维度、支持新的代码源（如 GitLab）或集成不同的 LLM。

## 5. 数据模型 (初步设想)

- `User`: (GitHub User ID, GitHub Access Token (encrypted), etc.)
- `Repository`: (Repo ID, Name, URL, User link)
- `AnalysisSession`: (Session ID, User link, Repo link, StartDate, EndDate, Status, etc.)
- `AnalyzedCommit`: (Commit SHA, AnalysisSession link, Commit Message, Commit Date, Author)
- `CodeSnippetAnalysis`: (Snippet ID, AnalyzedCommit link, File Path, Line Numbers, Original Code, LLM_Feedback_Raw, LLM_Feedback_Structured (e.g., {dimension: 'readability', issue: '...', suggestion: '...', explanation: '...'}), UserNotes)

## 6. 技术栈考量 (供参考)

- **后端：** Node.js (如 Koa/Express) / Python (Django/Flask) - 鉴于您当前文件名 `koa-server`，Node.js 可能是自然选择。
- **前端：** React / Vue / Svelte
- **数据库：** PostgreSQL / MongoDB
- **LLM 集成：** 通过 API 调用 OpenAI GPT 系列、Claude，或本地部署模型如 Llama 系列、Mistral 等。

## 7. 未来展望

- 集成 IDE 插件，进行更即时的反馈。
- 引入更细致的趋势分析和可视化，展示开发者在特定技能上的成长曲线。
- 基于分析结果，智能推荐相关的学习资源或代码示例。
- 支持团队的代码审查辅助功能。

---

这份文档旨在为您提供一个清晰的起点。在开发过程中，我们可以根据实际情况和反馈进行迭代和调整。预祝项目顺利！
